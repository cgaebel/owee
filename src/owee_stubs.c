#include <stdlib.h>
#include <stdio.h>

#include <caml/memory.h>
#include <caml/address_class.h>

/* Assumptions on caml startup code:
 *
 * caml_startup__code_begin
 *  caml_curry_*
 *  caml_tuplify_*
 *  caml_send_*
 *  caml_apply_*
 * caml_startup__code_end
 *
 * When taking code pointer from a closure, check if code pointer lies between
 * caml_startup__code_begin and caml_startup__code_end.
 *
 * If not, return it directly.
 * Otherwise, scan the rest of the fields for a value between
 * caml_code_area_start and caml_code_area_end, use it as the valid code pointer.
 */

/* Assume these symbols are always generated by ocamlopt */
extern void *caml_startup__code_begin;
extern void *caml_startup__code_end;

static void *closure_code_pointer(value closure)
{
  unsigned i;
  void *cp = (void*)Field(closure, 0);

  /* Normal code pointer */
  if (cp < (void*)&caml_startup__code_begin || cp > (void*)&caml_startup__code_end)
    return cp;

  for (i = 1; i < Wosize_val(closure); ++i)
  {
    void *cp2 = (void*)Field(closure, i);
    if (cp2 >= (void*)caml_code_area_start && cp2 <= (void*)caml_code_area_end)
      return cp2;
  }

  return cp;
}

CAMLprim value ml_owee_code_pointer(value closure)
{
  void *result = closure_code_pointer(closure);
  return ((intnat)result | 1);
}
