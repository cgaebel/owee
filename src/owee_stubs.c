#include <stdlib.h>
#include <stdio.h>

#include <caml/memory.h>
#include <caml/address_class.h>

/* Use dladdr. Should work at least with Linux, FreeBSD and OS X. */
#define _GNU_SOURCE
/* Because the previous one is sometime ignored. The pile of crap get worse */
#define __USE_GNU

#include <dlfcn.h>

CAMLprim value
ml_owee_get_symbol (value name)
{
  CAMLparam1 (name);
  CAMLlocal1 (ret);
  ret = (value) dlsym (NULL, String_val (name)) | 1;
  CAMLreturn (ret);
}

/* Assumptions on caml startup code:
 *
 * caml_startup__code_begin
 *  caml_curry_*
 *  caml_tuplify_*
 *  caml_send_*
 *  caml_apply_*
 * caml_startup__code_end
 *
 * When taking code pointer from a closure, check if code pointer lies between
 * caml_startup__code_begin and caml_startup__code_end.
 *
 * If not, return it directly.
 * Otherwise, we have to distinguish between caml_curry, caml_tuplify,
 * caml_send, caml_apply.
 *
 * We will try to compute first and last function of each kind:
 *
 * caml_startup__code_begin
 *  caml_unknown_begin
 *  caml_curry_first
 *  caml_curry_*
 *  caml_curry_last
 *  caml_other_first
 *  caml_tuplify_*
 *  caml_send_*
 *  caml_other_last
 *  caml_apply_first
 *  caml_apply_*
 *  caml_apply_last
 *  caml_unknown_end
 * caml_startup__code_end
 *
 */

/* Assume these symbols are always generated by ocamlopt */
extern void *caml_startup__code_begin;
extern void *caml_startup__code_end;

/*extern void *caml_code_area_start;
extern void *caml_code_area_end;*/

static void *closure_code_pointer(value closure)
{
  unsigned i;

  /*static int init = 0;
  static void *caml_startup__code_begin, *caml_startup__code_end;

  if (init == 0)
  {
    init = 1;
    caml_startup__code_begin = dlsym(NULL, "caml_startup__code_begin");
    caml_startup__code_end = dlsym(NULL, "caml_startup__code_end");
  }*/

  void *cp = (void*)Field(closure, 0);
  /*value last;*/
  /*Dl_info info;*/

  /*printf ("%p\n", cp);*/
  /* Normal code pointer */
  if (cp < (void*)&caml_startup__code_begin || cp > (void*)&caml_startup__code_end)
    return cp;

  for (i = 1; i < Wosize_val(closure); ++i)
  {
    void *cp2 = (void*)Field(closure, i);
    if (cp2 >= (void*)caml_code_area_start && cp2 <= (void*)caml_code_area_end)
      return cp2;
  }

  return cp;

  /*last = Field(closure, Wosize_val(closure) - 1);
  if (Is_block(last)) {
    if (!Is_in_heap_or_young(last))
      return (void*)last;
    if (Tag_val(last) == Closure_tag)
      return closure_code_pointer(closure);
  }
  return (void*)last;*/
}

#if 0
extern void *caml_startup__code_begin;
extern void *caml_curry2;
extern void *caml_apply2;
extern void *caml_startup__code_end;

static void *caml_unknown_begin = &caml_startup__code_begin;

static void *caml_curry_first = &caml_curry2;
static void *caml_curry_last = &caml_curry2;

static void *caml_other_first = NULL;
static void *caml_other_last = NULL;

static void *caml_apply_first = &caml_apply2;
static void *caml_apply_last = &caml_apply2;

static void *caml_unknown_end = &caml_startup__code_end;

static int prefix_of(const char *prefix, const char *of)
{
  if (of == NULL)
    return 0;

  while (*prefix && *of && *prefix == *of) {
    prefix++;
    of++;
  }

  return (*prefix == '\0');
}

#define min(a, b) (a <= b ? a : b)
#define max(a, b) (a >= b ? a : b)

/* Call to caml_curry: last field is another closure */
#define caml_curry_code_pointer(closure) \
  closure_code_pointer(Field(closure, Wosize_val(closure) - 1))

/* Call to caml_apply: code pointer is the last field */
#define caml_apply_code_pointer(closure) \
  (void*)Field(closure, Wosize_val(closure) - 1)

static void *closure_code_pointer(value closure)
{
  void *cp = (void*)Field(closure, 0);
  value last;
  /*Dl_info info;*/

  /* Normal code pointer */
  if (cp < (void*)&caml_startup__code_begin || cp > (void*)&caml_startup__code_end)
    return cp;

  /*************************************/
  /* Call to caml primitive, fast path */
  /*************************************/

  if (cp >= caml_apply_first && cp <= caml_apply_last)
    return caml_apply_code_pointer(closure);

  if (cp >= caml_curry_first && cp <= caml_curry_last)
    return caml_curry_code_pointer(closure);

  /* Don't know what that is, return normal code pointer */
  if (cp >= caml_other_first && cp <= caml_other_last)
    return cp;
  if (cp <= caml_unknown_begin || cp >= caml_unknown_end)
    return cp;

  /*************************************/
  /* Call to caml primitive, slow path */
  /*************************************/

  /* Still unknown: introspect symbol names to find out */
  if (dladdr(cp, &info) != 0)
  {
    if (prefix_of("caml_curry", info.dli_sname)) {
      caml_curry_first = min(caml_curry_first, cp);
      caml_curry_last = max(caml_curry_last, cp);

      return caml_curry_code_pointer(closure);
    }

    if (prefix_of("caml_apply", info.dli_sname)) {
      caml_apply_first = min(caml_apply_first, cp);
      caml_apply_last = max(caml_apply_last, cp);

      return caml_apply_code_pointer(closure);
    }

    /* Introspection didn't help, update unknown ranges */
    if (cp >= caml_curry_last)
      caml_other_first = min(cp, caml_other_first);
    else if (cp <= caml_curry_first)
      caml_unknown_begin = max(caml_unknown_begin, cp);

    if (cp <= caml_apply_first)
      caml_other_last = max(cp, caml_other_last);
    else if (cp >= caml_apply_last)
      caml_unknown_end = min(caml_unknown_end, cp);

    return cp;
  }
  else
  {
    /* No support for dladdr: just disable resolution of caml primitives */
    caml_other_first = &caml_startup__code_begin;
    caml_other_last = &caml_startup__code_end;
    return cp;
  }
}
#endif

CAMLprim value ml_owee_code_pointer(value closure)
{
  void *result = closure_code_pointer(closure);
  return ((intnat)result | 1);
}
